<!DOCTYPE html>
<html lang="en">

<head>
    <title>Why null sucks, even if it&#x27;s checked</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>
    <meta name="author" content="Maybe Waffle">

    <meta name="theme-color" content="#EE72F1">

    
    
    <meta name="title" content="Why null sucks, even if it&#x27;s checked">
    <meta name="description" content="We all know that `null` is a &quot;billion-dollar mistake&quot;, that it creates a lot of easy ways to make terrible mistakes. But it&#x27;s only so bad when it&#x27;s not checked by anyone and the compiler doesn&#x27;t force you to check it, right? Well, the title might be a spoiler, but let&#x27;s find out...">
    <meta name="image" content="https://ihatereality.space/you_cant_escape_from_reality_450x450.png">

    
        <meta name="keywords" itemprop="tags" content="kotlin, csharp, java, scala, haskell, rust, go, swift">
    

    <!-- Facebook Meta Tags -->
    <meta property="og:url" content="https://ihatereality.space/01-why-null-sucks/">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Why null sucks, even if it&#x27;s checked">
    <meta property="og:description" content="We all know that `null` is a &quot;billion-dollar mistake&quot;, that it creates a lot of easy ways to make terrible mistakes. But it&#x27;s only so bad when it&#x27;s not checked by anyone and the compiler doesn&#x27;t force you to check it, right? Well, the title might be a spoiler, but let&#x27;s find out...">
    <meta property="og:image" content="https://ihatereality.space/you_cant_escape_from_reality_450x450.png">
    <meta property="og:locale" content="en">

    
        <meta property="article:published_time" content="2021-08-20">
    

    
        
            <meta property="article:tag" content="kotlin">
        
            <meta property="article:tag" content="csharp">
        
            <meta property="article:tag" content="java">
        
            <meta property="article:tag" content="scala">
        
            <meta property="article:tag" content="haskell">
        
            <meta property="article:tag" content="rust">
        
            <meta property="article:tag" content="go">
        
            <meta property="article:tag" content="swift">
        
    

    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary">
    <meta property="twitter:domain" content="ihatereality.space">
    <meta property="twitter:url" content="https://ihatereality.space/01-why-null-sucks/">
    <meta name="twitter:title" content="Why null sucks, even if it&#x27;s checked">
    <meta name="twitter:description" content="We all know that `null` is a &quot;billion-dollar mistake&quot;, that it creates a lot of easy ways to make terrible mistakes. But it&#x27;s only so bad when it&#x27;s not checked by anyone and the compiler doesn&#x27;t force you to check it, right? Well, the title might be a spoiler, but let&#x27;s find out...">
    <meta name="twitter:image" content="https://ihatereality.space/you_cant_escape_from_reality_450x450.png">
    <meta name="twitter:creator" content="maybewaffle">



    
    <link rel="stylesheet" href="https://ihatereality.space/style.css">
    <link rel="stylesheet" href="https://ihatereality.space/color/pink.css">

    <link rel="stylesheet" href="https://ihatereality.space/font-hack.css">


    
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://ihatereality.space/rss.xml">
    
        <link rel="shortcut icon" type="image&#x2F;png" href="/you_cant_escape_from_reality_128x128.png">
    
    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://ihatereality.space" style="text-decoration: none;">
                    <div class="logo">
                            I hate reality
                        </div>
                </a>
            </div>
        </div>

        <nav class="menu">
            <ul class="menu__inner">
                <li><a href="https://ihatereality.space/about">about</a></li>
            
                <li><a href="https://github.com/iloathereality/blog" target="_blank" rel="noopener noreferrer">source</a></li>
            </ul>
        </nav>
    
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://ihatereality.space/01-why-null-sucks/">Why null sucks, even if it&#x27;s checked</a></h1>
    
        <div class="post-meta-inline">
            
    <span class="post-date">
            2021-08-20
        
            [updated 2022-07-08]
        
    </span>

            
    <span class="post-read-time">
        :: 16 min read
    </span>


            <!-- TODO: rethink how tags look -->
            <br>
            
        <span class="post-tags-inline"><a class="post-tag" href="https://ihatereality.space/tags/kotlin/">#kotlin</a> <a class="post-tag" href="https://ihatereality.space/tags/csharp/">#csharp</a> <a class="post-tag" href="https://ihatereality.space/tags/java/">#java</a> <a class="post-tag" href="https://ihatereality.space/tags/scala/">#scala</a> <a class="post-tag" href="https://ihatereality.space/tags/haskell/">#haskell</a> <a class="post-tag" href="https://ihatereality.space/tags/rust/">#rust</a> <a class="post-tag" href="https://ihatereality.space/tags/go/">#go</a> <a class="post-tag" href="https://ihatereality.space/tags/swift/">#swift</a></span>
    
        </div>
    


        
        <div class="post-content">
            <p>We all know that <code>null</code> is a <a href="https://en.wikipedia.org/wiki/Null_pointer#History">“billion-dollar mistake”</a>, that it creates a lot of easy ways to make terrible mistakes. But it’s only so bad when it’s not checked by anyone and the compiler doesn’t force you to check it, right? Well, the title might be a spoiler, but let’s find out…</p>
<span id="continue-reading"></span><h1 id="context-what-are-you-talking-about">Context / What are you talking about?<a class="zola-anchor" href="#context-what-are-you-talking-about" aria-label="Anchor link for: context-what-are-you-talking-about">⌗</a></h1>
<p>In this article, I’m specifically talking about the <a href="https://kotlinlang.org/docs/null-safety.html">Kotlin</a> and <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#nullable-reference-types">C# post v8</a> approach to <code>null</code>. I’m more familiar with Kotlin than C#, so I’ll mostly be talking about it, but their approaches are similar, so that doesn’t really matter.</p>
<p>Basically, you can’t assign null to just any reference type in Kotlin (and C# post v8 with certain settings). For example, this is a compilation error:</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#65737e;">// compilation error
</span><span style="color:#b48ead;">val </span><span>a: </span><span style="color:#b48ead;">String </span><span>= </span><span style="color:#d08770;">null</span><span>;
</span><span>
</span><span style="color:#65737e;">// ok
</span><span style="color:#b48ead;">var </span><span>b: </span><span style="color:#b48ead;">String </span><span>= &quot;</span><span style="color:#a3be8c;">not null</span><span>&quot;;
</span><span>
</span><span style="color:#65737e;">// compilation error (again)
</span><span>b = </span><span style="color:#d08770;">null</span><span>;
</span></code></pre>
<p>And since you can’t assign <code>null</code> to non-nullable types, <code>null</code> can’t screw you! You can’t get a null pointer (reference) exception, etc. Cool!</p>
<p>If you really want to assign null to something, you need to explicitly mark the type of the variable as nullable with <code>T?</code> syntax:</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#65737e;">// ok
</span><span style="color:#b48ead;">val </span><span>a: </span><span style="color:#b48ead;">String</span><span>? = </span><span style="color:#d08770;">null</span><span>;
</span><span>
</span><span style="color:#65737e;">// also ok
</span><span style="color:#b48ead;">var </span><span>b: </span><span style="color:#b48ead;">String</span><span>? = &quot;</span><span style="color:#a3be8c;">not null</span><span>&quot;;
</span><span>b = </span><span style="color:#d08770;">null</span><span>;
</span></code></pre>
<p>But when you have a <code>T?</code> (nullable) type, you also need to explicitly check for null. E.g. given a class <code>Mine</code> with a <code>cat</code> field and a variable <code>mine</code> of type <code>Mine?</code>, you can’t access <code>mine.cat</code>, it would be a compilation error:</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">val </span><span>mine: Mine? = </span><span style="color:#65737e;">/* ... */
</span><span style="color:#b48ead;">val </span><span>your: Mine  = </span><span style="color:#65737e;">/* ... */
</span><span>
</span><span style="color:#65737e;">// compilation error
</span><span style="color:#b48ead;">val </span><span>a: Cat = mine.cat
</span><span>
</span><span style="color:#65737e;">// elvis operator, if `mine` is null,
</span><span style="color:#65737e;">// then `your` will be used
</span><span style="color:#b48ead;">val </span><span>b: Cat = (mine ?: your).cat  
</span><span>
</span><span style="color:#65737e;">// safe call operator, if `mine` is null, 
</span><span style="color:#65737e;">// then so be `c`        
</span><span style="color:#b48ead;">val </span><span>c: Cat? = mine?.cat
</span><span>
</span><span style="color:#65737e;">// “trust me, I&#39;m an engineer” operator, 
</span><span style="color:#65737e;">// throws an exception if `mine` is null 
</span><span style="color:#b48ead;">val </span><span>d: Cat = mine!!.cat
</span><span>
</span><span style="color:#b48ead;">if</span><span> mine != </span><span style="color:#d08770;">null</span><span> {
</span><span>    </span><span style="color:#65737e;">// Special Kotlin trick: 
</span><span>    </span><span style="color:#65737e;">// in this block `mine` actually has type `Mine`.
</span><span>
</span><span>    </span><span style="color:#65737e;">// perfectly fine (we&#39;ve checked)
</span><span>    </span><span style="color:#b48ead;">val </span><span>x: Cat = mine.cat
</span><span>}
</span></code></pre>
<p>(The same applies for calling a function with an argument of non-nullable type, you need to either check that something is not null or explicitly assume so)</p>
<p>The “special kotlin trick” is called “smart cast”. Basically, if you check that a variable is not null (or has a particular type), then the compiler changes type of the variable in the block, where the check holds. You can read more about it in Kotlin docs: <a href="https://kotlinlang.org/docs/typecasts.html#smart-casts">typecasts</a>, <a href="https://kotlinlang.org/docs/null-safety.html#checking-for-null-in-conditions">null-safety</a>.</p>
<p>And it’s all great, don’t get me wrong! This behaviour is a lot better than the plain old “every reference can be null, just crash if it is and it’ll be fine”. However…</p>
<h1 id="why-it-s-still-meh">Why it’s still meh<a class="zola-anchor" href="#why-it-s-still-meh" aria-label="Anchor link for: why-it-s-still-meh">⌗</a></h1>
<p>In my opinion, this comes down to 2 things: generality and extensibility.</p>
<h2 id="generality">Generality<a class="zola-anchor" href="#generality" aria-label="Anchor link for: generality">⌗</a></h2>
<p>In modern languages, we have ways to abstract over types. Usually, the mechanism to do so is called generics. For example, a <code>HashMap</code> doesn’t care what the key and value types are, it only cares that the key is comparable and hashable. Thus you can have <code>HashMap&lt;String, i32&gt;</code>, <code>HashMap&lt;User, Settings&gt;</code>, etc while only writing <code>HashMap</code> once. </p>
<p>That’s all good and all, but what’s the problem? You may ask. Well… Consider this example: the <code>HashMap</code> has a method <code>get</code> which accepts key and returns the value associated with the key if there is one. But what should it return if there is no value associated with the key? It seems reasonable to return <code>null</code> since there is no value. So something like this:</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">HashMap</span><span>&lt;</span><span style="color:#b48ead;">K</span><span>, </span><span style="color:#b48ead;">V</span><span>&gt; {
</span><span>    </span><span style="color:#65737e;">// If `key` is present in the hash map, 
</span><span>    </span><span style="color:#65737e;">// returns the value associated with it. 
</span><span>    </span><span style="color:#65737e;">// Otherwise returns `null`.
</span><span>    </span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">get</span><span>(key: K): V? { </span><span style="color:#65737e;">/* ... */</span><span> }
</span><span>}
</span></code></pre>
<p>But what happens if we use <code>HashMap&lt;_, T?&gt;</code>? Well, then <code>V</code> is <code>T?</code> and so <code>V?</code> is <code>T??</code> which is the same as <code>T?</code> because there is only one <code>null</code> value. </p>
<p>The crux of the problem is this: you can’t distinguish between “absence of value” (no key in the map) and “presence of absence of value” (value is <code>null</code>). And if you need to distinguish them, then you need to call <code>containsKey</code> or something which is suboptimal.</p>
<p>This is just a simple example, but in general, you can’t use <code>null</code> in generic code because <code>null</code> is too special and <strong>unique</strong>.</p>
<h2 id="extensibility">Extensibility<a class="zola-anchor" href="#extensibility" aria-label="Anchor link for: extensibility">⌗</a></h2>
<p><code>null</code> is not extensible. This mechanism is only useful when you have an optional value: either there is a value, or there isn’t. </p>
<p>It isn’t useful when you need to express errors (<code>null</code> is used for this anyway, but this is problematic), exclusive or (either you have <code>A</code> or <code>B</code>, but not both and not neither), etc. </p>
<p>It may seem like this isn’t a problem — we were talking about expressing optional values from the very beginning. But bear with me, and for now just understand that <code>null</code> is not extensible and there may be other, more extensible, mechanisms.</p>
<h1 id="the-saviour">The saviour?<a class="zola-anchor" href="#the-saviour" aria-label="Anchor link for: the-saviour">⌗</a></h1>
<p>As I said before, there may be a more general and extensible way to handle optional values. And there is! It has a lot of different names — sum types, enumerations, tagged unions, discriminated unions, etc. They’re all conceptually similar, but I like the “sum types” name the most, so that’s what I’ll call it.</p>
<p>In any case, the concept stays the same — a type that can represent one out of multiple choices. Here are some well-known examples of definitions of sum types:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">enum </span><span>Option&lt;T&gt; { None, Some(T) }
</span><span style="color:#b48ead;">enum </span><span>Either&lt;L, R&gt; { Left(L), Right(R) }
</span></code></pre>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">data </span><span style="color:#d08770;">Maybe</span><span> a = </span><span style="color:#d08770;">Nothing </span><span>| </span><span style="color:#d08770;">Just</span><span> a
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Either</span><span> a b = </span><span style="color:#d08770;">Left</span><span> a | </span><span style="color:#d08770;">Right</span><span> b
</span></code></pre>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>I’ve shown examples in Rust and Haskell because I’m familiar with them but note that sum types exist in <a href="https://en.wikipedia.org/wiki/Algebraic_data_type#Programming_languages_with_algebraic_data_types">many languages</a>. </p>

  </div>
</div>
<p><code>Option</code> (<code>Maybe</code>) is exactly what we’re looking for! It can be either <code>None</code> (<code>Nothing</code>) or <code>Some(value)</code> (<code>Just value</code>). So either there is nothing or there is some value, exactly the same as with <code>null</code> so far. </p>
<p>But it actually solves all the <code>null</code> problems I’ve mentioned!</p>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>Another nice fact about <code>Option</code> (<code>Maybe</code>) is that it can be defined in a library. Unlike nullable types, there’s nothing special about this type. The compiler doesn’t need to know about it, it’s just a type.</p>

  </div>
</div><h2 id="generality-1">Generality<a class="zola-anchor" href="#generality-1" aria-label="Anchor link for: generality-1">⌗</a></h2>
<p><code>Option&lt;Option&lt;T&gt;&gt;</code> is a meaningful type, unlike <code>T??</code>. In the same example with <code>HashMap::get</code> there isn’t any problems if it returns <code>Option&lt;V&gt;</code>.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl</span><span>&lt;K, V&gt; HashMap&lt;K, V&gt; {
</span><span>    </span><span style="color:#65737e;">// If `key` is present in the hash map, 
</span><span>    </span><span style="color:#65737e;">// returns the value associated with it. 
</span><span>    </span><span style="color:#65737e;">// Otherwise returns `None`.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">key</span><span>: &amp;K) -&gt; Option&lt;V&gt; { </span><span style="color:#65737e;">/* ... */ </span><span>}
</span><span>}
</span></code></pre>
<p>If the key isn’t present in the <code>HashMap&lt;K, Option&lt;V&gt;&gt;</code>, then <code>None</code> is returned. If the key is present but the associated value is <code>None</code>, <code>Some(None)</code> is returned. Otherwise, if the key is present and the value isn’t <code>None</code>, then <code>Some(Some(value))</code> is returned. </p>
<p>The use of sum types gives us 3 distinct kinds of values that can be distinguished from one another, instead of an ambiguous null.</p>
<h2 id="extensibility-1">Extensibility<a class="zola-anchor" href="#extensibility-1" aria-label="Anchor link for: extensibility-1">⌗</a></h2>
<p>Sum types can be used for optional values via <code>Option</code>-like types. But they are not limited to only this. You can define your own sum types. It’s very handy when you need to return errors (See Rust <a href="https://doc.rust-lang.org/std/result/index.html"><code>Result</code></a> for example), define the errors themselves or just in general when you need to hold different kinds (types) of data in one place. </p>
<h2 id="explicitness">Explicitness<a class="zola-anchor" href="#explicitness" aria-label="Anchor link for: explicitness">⌗</a></h2>
<p>There is one thing you may prefer about <code>null</code> over sum types: <code>T</code> can be <a href="https://en.wikipedia.org/wiki/Type_conversion">coerced</a> to <code>T?</code>.  That means that you don’t need to explicitly wrap values in <code>Some</code> (<code>Just</code>). </p>
<p>This may be handy, because you need to type ~6 characters less if you want to pass <code>T</code> to a function that accepts <code>T?</code>. However, I don’t think that wrapping inconvenience outweighs the benefits of sum types.</p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">f</span><span>(x: </span><span style="color:#b48ead;">Int</span><span>?): </span><span style="color:#b48ead;">Int</span><span>? = x?.let { it + </span><span style="color:#d08770;">1</span><span> }
</span><span style="color:#b48ead;">val </span><span>res = f(</span><span style="color:#d08770;">1</span><span>)
</span></code></pre>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">f</span><span>(</span><span style="color:#bf616a;">x</span><span>: Option&lt;</span><span style="color:#b48ead;">i32</span><span>&gt;) -&gt; Option&lt;</span><span style="color:#b48ead;">i32</span><span>&gt; { x.</span><span style="color:#96b5b4;">map</span><span>(|</span><span style="color:#bf616a;">it</span><span>| it + </span><span style="color:#d08770;">1</span><span>) }
</span><span style="color:#b48ead;">let</span><span> res = </span><span style="color:#96b5b4;">f</span><span>(Some(</span><span style="color:#d08770;">1</span><span>));
</span><span style="color:#65737e;">//          ^^^^^ ^
</span></code></pre>
<p><del>It would be interesting to see a language with sum types and <code>T</code> to <code>Option&lt;T&gt;</code> coercion though 👀</del> (see note about Swift down below)</p>
<h1 id="niche-optimization">Niche optimization<a class="zola-anchor" href="#niche-optimization" aria-label="Anchor link for: niche-optimization">⌗</a></h1>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>I could only find mentions of this optimization in Rust, but I think it’s very neat anyway, so I’ll talk about Rust in this paragraph.</p>

  </div>
</div>
<p>There are some types that have unused space in their memory representation — a <em>niche</em>. For example, <code>bool</code> is only 1 bit of information, but it uses 1 byte of space, so 7 bits are unused. References (<code>&amp;T</code>, <code>&amp;mut T</code>) and <code>NonNull</code> can never be null, meaning that they have an unused bit pattern — all zeroes. The same goes with <a href="https://doc.rust-lang.org/std/num/index.html"><code>NonZero*</code></a>. Enumerations, just as <code>bool</code>, can have unused bits/bit patterns.</p>
<p>What if we could use this for something actually useful? Well, Rust can.</p>
<p>If a sum type has one of its variants being a type with a niche, then it can use it to represent other variants, instead of using a tag. I.e. <code>Option&lt;&amp;T&gt;</code> isn’t identical to <code>struct { value: union { Some(&amp;T), None }, tag: u8 }</code> (pseudo syntax), but instead it’s just <code>union { Some(&amp;T), None }</code> where the <code>None</code> is encoded as <code>0</code> (since reference can never be <code>0</code> you can distinguish variants without a <code>tag</code>). Moreover, this exact optimization of <code>Option&lt;&amp;T&gt;</code> is even <a href="https://doc.rust-lang.org/std/option/index.html#representation">guaranteed</a>, so it is fully layout compatible with <code>*const T</code>. This allows using it in C-ffi, making <code>None</code> on the Rust side a <code>null</code> on the C side.</p>
<p>This optimization can be observed using <code>mem::size_of</code> function:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// `u8`, `bool` and `Option&lt;bool&gt;` all occupy 1 byte.
</span><span style="color:#65737e;">// `Option::&lt;bool&gt;::None` is encoded as 2. It&#39;s fine, since `bool`
</span><span style="color:#65737e;">// can only ever by 1 or 0.
</span><span>size_of::&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;() = </span><span style="color:#d08770;">1
</span><span>size_of::&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;() = </span><span style="color:#d08770;">1
</span><span>size_of::&lt;Option&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;&gt;() = </span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;, </span><span style="color:#b48ead;">u8</span><span>&gt;(None) } = </span><span style="color:#d08770;">2
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;, </span><span style="color:#b48ead;">u8</span><span>&gt;(Some(</span><span style="color:#d08770;">true</span><span>)) } = </span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;, </span><span style="color:#b48ead;">u8</span><span>&gt;(Some(</span><span style="color:#d08770;">false</span><span>)) } = </span><span style="color:#d08770;">0
</span><span>
</span><span style="color:#65737e;">// `Option&lt;Option&lt;bool&gt;&gt;` behaves similarly, it just needs 2 patterns.
</span><span>size_of::&lt;Option&lt;Option&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;&gt;&gt;() = </span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;Option&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;&gt;, </span><span style="color:#b48ead;">u8</span><span>&gt;(None) } = </span><span style="color:#d08770;">3
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;Option&lt;</span><span style="color:#b48ead;">bool</span><span>&gt;&gt;, </span><span style="color:#b48ead;">u8</span><span>&gt;(Some(None)) } = </span><span style="color:#d08770;">2
</span><span>
</span><span style="color:#65737e;">// On 64 bit machines references take 8 bytes.
</span><span style="color:#65737e;">// `Option::&lt;&amp;_&gt;::None` is encoded as a `0`/`null`.
</span><span>size_of::&lt;&amp;</span><span style="color:#b48ead;">u8</span><span>&gt;() = </span><span style="color:#d08770;">8
</span><span>size_of::&lt;Option&lt;&amp;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;() = </span><span style="color:#d08770;">8
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;&amp;</span><span style="color:#b48ead;">u8</span><span>&gt;, </span><span style="color:#b48ead;">*mut u8</span><span>&gt;(None) } = </span><span style="color:#d08770;">0x0000000000000000
</span><span>
</span><span style="color:#65737e;">// `u8` has no niche, so `Option` needs a tag (in this case: first byte)
</span><span>size_of::&lt;Option&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;() = </span><span style="color:#d08770;">2
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;, Pair&lt;</span><span style="color:#b48ead;">u8</span><span>, MaybeUninit&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;&gt;(None) } = (</span><span style="color:#d08770;">0</span><span>, MaybeUninit&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;)
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;, [</span><span style="color:#b48ead;">u8</span><span>; </span><span style="color:#d08770;">2</span><span>]&gt;(Some(</span><span style="color:#d08770;">0xAA</span><span>)) } = [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">170</span><span>]
</span><span>
</span><span style="color:#65737e;">// You may have expected 9, instead of 16, 
</span><span style="color:#65737e;">// but in Rust, size is always a multiple of the alignment.
</span><span style="color:#65737e;">// References are 8-bytes aligned. The nearest 
</span><span style="color:#65737e;">// multiple of 8 bigger than 8 is 16.
</span><span>size_of::&lt;Option&lt;Option&lt;&amp;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;&gt;() = </span><span style="color:#d08770;">16
</span><span style="color:#65737e;">// It seems like the first word is tag and the second
</span><span style="color:#65737e;">// is optional reference.
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;Option&lt;&amp;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;, Pair&lt;</span><span style="color:#b48ead;">usize</span><span>, MaybeUninit&lt;</span><span style="color:#b48ead;">usize</span><span>&gt;&gt;&gt;(None) } = (</span><span style="color:#d08770;">0</span><span>, MaybeUninit&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;)
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;Option&lt;&amp;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;, [</span><span style="color:#b48ead;">usize</span><span>; </span><span style="color:#d08770;">2</span><span>]&gt;(Some(None)) } = [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>]
</span><span style="color:#b48ead;">unsafe </span><span>{ transmute::&lt;Option&lt;Option&lt;&amp;</span><span style="color:#b48ead;">u8</span><span>&gt;&gt;, [</span><span style="color:#b48ead;">usize</span><span>; </span><span style="color:#d08770;">2</span><span>]&gt;(Some(Some(&amp;</span><span style="color:#d08770;">1</span><span>))) } = [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">93965956011124</span><span>]
</span></code></pre>
<p><em>Edited output of the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0166b25cd98164e32879456d65a8e9b8">test program</a>.</em></p>
<h1 id="a-sad-note-kotlin">A sad note: Kotlin<a class="zola-anchor" href="#a-sad-note-kotlin" aria-label="Anchor link for: a-sad-note-kotlin">⌗</a></h1>
<p>Kotlin <em>does</em> support sum types via <a href="https://kotlinlang.org/docs/sealed-classes.html">sealed classes</a>. Here is an example how you could define and use <code>Option</code> (<a href="https://pl.kotl.in/XZ1fBjith">play</a>): </p>
<pre data-lang="kotlin" style="background-color:#2b303b;color:#c0c5ce;" class="language-kotlin "><code class="language-kotlin" data-lang="kotlin"><span style="color:#b48ead;">sealed class </span><span style="color:#ebcb8b;">Option</span><span>&lt;</span><span style="color:#b48ead;">T</span><span>&gt; {
</span><span>    </span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">None</span><span>&lt;</span><span style="color:#b48ead;">T</span><span>&gt;() : </span><span style="color:#a3be8c;">Option</span><span>&lt;</span><span style="color:#a3be8c;">T</span><span>&gt;() {}
</span><span>    </span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Some</span><span>&lt;</span><span style="color:#b48ead;">T</span><span>&gt;(</span><span style="color:#b48ead;">val </span><span>value: T) : </span><span style="color:#a3be8c;">Option</span><span>&lt;</span><span style="color:#a3be8c;">T</span><span>&gt;() {}
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fun </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">val </span><span>a: Option&lt;</span><span style="color:#b48ead;">Int</span><span>&gt; = Option.Some(</span><span style="color:#d08770;">12</span><span>);
</span><span>    </span><span style="color:#b48ead;">val </span><span>b = </span><span style="color:#b48ead;">when</span><span>(a) {
</span><span>        is Option.None -&gt; &quot;</span><span style="color:#a3be8c;">None</span><span>&quot;
</span><span>
</span><span>        </span><span style="color:#65737e;">// `a` is smart-casted to `Some`, so `value` is accessible.
</span><span>        </span><span style="color:#65737e;">// IMO pattern matching would be better, but that&#39;s ok.
</span><span>        is Option.Some -&gt; a.value.toString()
</span><span>    }
</span><span>    println(b)
</span><span>}
</span></code></pre>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>In my opinion, Kotlin’s support of sum types is extremely hacky, but who am I to say that, right?</p>

  </div>
</div>
<p>Nevertheless, Kotlin doesn’t use this for optional values! In fact, it doesn’t even have an <code>Option</code> class in the standard library. For me, it seems like a big omission. It seems like making <code>T?</code> equivalent to <code>Option&lt;T&gt;</code> and <code>Option&lt;N&gt;</code> (where <code>N</code> is not <code>Option</code>) be layout compatible with <code>Java</code>’s <code>N</code> (i.e. <code>Java</code>’s <code>null</code> being the same as <code>None&lt;N&gt;</code>) would be sufficient…</p>
<h1 id="a-sad-note-java-scala">A sad note: Java &amp; Scala<a class="zola-anchor" href="#a-sad-note-java-scala" aria-label="Anchor link for: a-sad-note-java-scala">⌗</a></h1>
<p>Originally I didn’t plan to say anything about Java (or Scala) — after all it is a classic example of why <strong>unchecked</strong> <code>null</code> is problematic.
Everyone (?) already knows that it’s hard to always remember to check for <code>null</code> by hand and that it causes <code>NullPointerException</code>s all of the time.
So it felt like brining up Java here wouldn’t be valuable.</p>
<p>But! Recently I was reminded that Java has an interesting unsoundness in its type system that is related to <code>null</code>.</p>
<p>In a nutshell Java (and similarly Scala) assumes that if a value of a type exists, then this type is well-formed.
Well-formedness means that the type is sensible, that all its type parameters satisfy their bounds.
When coupled with other features like wildcards in Java or path-dependant types in Scala, this allows you to create a type that proves a relationship between two types.
I.e. that one type is a subtype of another type.
You can then create a function that accepts such a proof of type relationship and coerce one type to another.</p>
<p>This is all sensible, because normally to create a value of a type you need to prove that it is well-formed.
However there is a flaw in this assumption: <code>null</code> (unsurprisingly, given the theme of this post).</p>
<p>You see, <code>null</code> makes all reference types inhabited, even the ones that are not well-formed.
As shown in the <a href="https://raw.githubusercontent.com/namin/unsound/master/doc/unsound-oopsla16.pdf">Java and Scala’s Type Systems are Unsound</a> paper <code>null</code> allows you to falsify the proof of type relationship, allowing to coerce any two types to each other.</p>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>The paper itself is a great read, I recommend reading it, if you haven’t already!</p>

  </div>
</div>
<p>This is another place where implicitness of <code>null</code> caused issues, quoting the paper:</p>
<blockquote>
<p>It [implicit-null feature] adds a case that is easy to forget and difficult to keep track of and reason about.
Interestingly, here it causes the same problem for the same reasons, but at the type level.
The reasoning for wildcards and path-dependent types would be perfectly valid if not for implicit <code>null</code> values</p>
</blockquote>
<h1 id="a-sad-note-c">A sad note: C#<a class="zola-anchor" href="#a-sad-note-c" aria-label="Anchor link for: a-sad-note-c">⌗</a></h1>
<p>C# doesn’t support sum types. To some extent they can be simulated using inheritance from an interface or abstract class, however, such an approach lacks one of the greatest benefits of sum types, namely the exhaustiveness check.</p>
<p>It’s especially sad since F# (which is running on the same VM) supports sum types (F# docs call them <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/discriminated-unions"><em>Discriminated Unions</em></a>), but C# doesn’t.</p>
<pre data-lang="f#" style="background-color:#2b303b;color:#c0c5ce;" class="language-f# "><code class="language-f#" data-lang="f#"><span style="color:#b48ead;">type </span><span>Option</span><span style="color:#b48ead;">&lt;</span><span>&#39;a</span><span style="color:#b48ead;">&gt; =</span><span> None </span><span style="color:#b48ead;">|</span><span> Some </span><span style="color:#b48ead;">of </span><span>&#39;a
</span><span style="color:#b48ead;">type </span><span>Either</span><span style="color:#b48ead;">&lt;</span><span>&#39;a</span><span style="color:#b48ead;">, </span><span>&#39;b</span><span style="color:#b48ead;">&gt; =</span><span> Left </span><span style="color:#b48ead;">of </span><span>&#39;a </span><span style="color:#b48ead;">|</span><span> Right </span><span style="color:#b48ead;">of </span><span>&#39;b
</span></code></pre>
<h1 id="a-sad-note-go">A sad note: Go<a class="zola-anchor" href="#a-sad-note-go" aria-label="Anchor link for: a-sad-note-go">⌗</a></h1>
<p>Go doesn’t support sum types. It’s a little sad on its own, but Go also doesn’t have exceptions and all reference types are implicitly nullable. This means that if a function wants to return an error, it needs to return a tuple of success and error values. This not only makes checking which is <code>null</code> (actually <code>nil</code>, but it’s the same thing) pretty annoying, but also leaves the possibility for an invalid state where neither success nor error values are <code>null</code>. </p>
<p>I think it’s inexcusable to have such error-prone design flaws for a language created in 2012.</p>
<h1 id="a-happy-note-swift">A happy note: Swift<a class="zola-anchor" href="#a-happy-note-swift" aria-label="Anchor link for: a-happy-note-swift">⌗</a></h1>
<p>I’m not very familiar with Swift, however I often hear that it has some interesting/ergonomic/nice features.
This time is not an exception — I was told that swift has both sum types and <code>T</code> -&gt; <code>Option&lt;T&gt;</code> coercion.</p>
<p>From what I’ve gathered from <a href="https://developer.apple.com/documentation/swift/optional">here</a> and <a href="https://www.programiz.com/swift-programming/optionals">here</a> in Swift the type is called <code>Optional&lt;Wrapped&gt;</code>.
It has two variants (or cases as they are called in Swift) — <code>some(Wrapped)</code> and <code>none</code>.
<code>switch</code> can be used to pattern match.</p>
<pre data-lang="swift" style="background-color:#2b303b;color:#c0c5ce;" class="language-swift "><code class="language-swift" data-lang="swift"><span style="color:#b48ead;">let</span><span> a: Optional&lt;Int&gt; = Optional.</span><span style="color:#b48ead;">none
</span><span style="color:#b48ead;">let</span><span> b: Optional&lt;Int&gt; = Optional.some(</span><span style="color:#d08770;">1</span><span>)
</span><span>
</span><span style="color:#b48ead;">switch</span><span> b {
</span><span style="color:#b48ead;">case let</span><span> Optional.some(x):
</span><span style="color:#65737e;">//   ^^^ --- let is needed to introduce new variables (`x`).
</span><span style="color:#65737e;">//           honestly, this is quite a good choice.
</span><span style="color:#65737e;">//           it allows to use `Optional.some(pat)`
</span><span style="color:#65737e;">//           to compare the wrapped value to `pat` variable.
</span><span>    print(x)
</span><span style="color:#b48ead;">case</span><span> Optional.</span><span style="color:#b48ead;">none</span><span>:
</span><span>    print(</span><span style="color:#a3be8c;">&quot;:(&quot;</span><span>)
</span><span>}
</span></code></pre>
<p>And then on top of that Swift adds a whole bunch of syntax sugar</p>
<ol>
<li><code>T?</code> can be used instead of <code>Optional&lt;T&gt;</code></li>
<li><code>T</code> can be coerced to <code>T?</code> (and coercions are transitive it seems, so <code>T</code> -&gt; <code>T???</code> is also supported)</li>
<li><code>nil</code> can be used instead of <code>Optional.none</code> (there is a coercion from <code>nil</code> literal to <code>T?</code>)</li>
<li><code>.variant</code> can be used if the type can be inferred (e.g. <code>.none</code> and <code>.some(16)</code>)</li>
<li><code>a?.b</code> can be used to do chaining / map access (<code>a.map(|x| x.b)</code> in Rust terms)</li>
<li><code>a ?? b</code> can be used to provide a default</li>
<li><code>if let x = a</code> assigns <code>x</code> to the inner value if <code>a</code> is <code>some</code> (syntax sugar for <code>if case let Optional.some(x) = a {</code>)</li>
<li><code>guard let x = a else { return }</code> can be used to early-return if a value is not <code>some</code></li>
<li><code>a!</code> can be used to unwrap a variable crashing if it’s <code>none</code></li>
<li>and more (probably (I’m a little tired of writing this list))</li>
</ol>
<p><em>Personally</em>, I’d say that’s a bit too much sugar and I’m a little concerned how coercions interact with generic code.
But overall I think that’s a pretty nice feature set and I guess it’s nice to use all of this.
I wish more languages went in direction “make <code>Optional</code> nicer” instead of “make <code>null</code>” nicer (yes, I’m still looking at you, Kotlin).</p>
 


  

  
    
  


<div class="callout">
  <img 
    class="callout-icon"
    src="/twemoji/assets/svg/1f438.svg"
    alt="🐸"
  />
  <div class="callout-body">
    <p>Also Swift gets it right and calls the <code>T? -&gt; (T -&gt; U?) -&gt; U?</code> function <code>flatMap</code>. Yes, I’m looking at you, Rust.</p>

  </div>
</div><h1 id="conclusion">Conclusion<a class="zola-anchor" href="#conclusion" aria-label="Anchor link for: conclusion">⌗</a></h1>
<p>There is no nice conclusion. The reality is painful as usual. We are stuck with a 56-year old abstraction that has proven itself to be error-prone for a while now. We are stuck with it, even though a better solution exists for longer than I have.</p>
<p>bye.</p>

        </div>

        
        <div class="pagination">
            <div class="pagination__title">
                <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                <hr />
            </div>
            <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://ihatereality.space/devlog-00/">
                            <span class="button__icon">←</span>&nbsp;
                            <span class="button__text">Waffle Devlog 0</span>
                        </a>
                    </span>
                
                </div>
        </div>
    
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright copyright--user"><div class="copyright"><span>© 2021 Maybe Waffle</span><span class="copyright-theme"><span class="copyright-theme-sep">:: </span>Theme is based on <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a></span><span class="copyright-theme-sep">:: </span><a href="/rss.xml">rss</a></div></div>
            </div>
    </footer>
    

</div>

<!-- Tracking via https://www.goatcounter.com/ -->
<script data-goatcounter="https://ihr.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</body>

</html>
